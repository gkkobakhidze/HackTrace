"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chat = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../constants");
const pushAPITypes_1 = require("./pushAPITypes");
const PUSH_USER = require("../user");
const PUSH_CHAT = require("../chat");
const helpers_1 = require("../chat/helpers");
const helpers_2 = require("../helpers");
const updateGroupProfile_1 = require("../chat/updateGroupProfile");
const user_1 = require("./user");
class Chat {
    constructor(account, decryptedPgpPvtKey, env, signer, progressHook) {
        this.account = account;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.env = env;
        this.signer = signer;
        this.progressHook = progressHook;
        this.group = {
            create: (name, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const groupParams = {
                    groupName: name,
                    groupDescription: options === null || options === void 0 ? void 0 : options.description,
                    members: (options === null || options === void 0 ? void 0 : options.members) ? options.members : [],
                    groupImage: options === null || options === void 0 ? void 0 : options.image,
                    admins: (options === null || options === void 0 ? void 0 : options.admins) ? options.admins : [],
                    rules: options === null || options === void 0 ? void 0 : options.rules,
                    isPublic: !(options === null || options === void 0 ? void 0 : options.private),
                    signer: this.signer,
                    pgpPrivateKey: this.decryptedPgpPvtKey,
                    env: this.env,
                };
                return yield PUSH_CHAT.createGroup(groupParams);
            }),
            permissions: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const getGroupAccessOptions = {
                    chatId,
                    did: this.account,
                    env: this.env,
                };
                return yield PUSH_CHAT.getGroupAccess(getGroupAccessOptions);
            }),
            info: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return yield PUSH_CHAT.getGroup({
                    chatId: chatId,
                    env: this.env,
                });
            }),
            update: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const group = yield PUSH_CHAT.getGroup({
                    chatId: chatId,
                    env: this.env,
                });
                if (!group) {
                    throw new Error('Group not found');
                }
                const updateGroupProfileOptions = {
                    chatId: chatId,
                    groupName: options.name ? options.name : group.groupName,
                    groupImage: options.image ? options.image : group.groupImage,
                    groupDescription: options.description
                        ? options.description
                        : group.groupDescription,
                    scheduleAt: options.scheduleAt ? options.scheduleAt : group.scheduleAt,
                    scheduleEnd: options.scheduleEnd
                        ? options.scheduleEnd
                        : group.scheduleEnd,
                    status: options.status ? options.status : group.status,
                    meta: options.meta ? options.meta : group.meta,
                    rules: options.rules ? options.rules : group.rules,
                    account: this.account,
                    pgpPrivateKey: this.decryptedPgpPvtKey,
                    env: this.env,
                };
                return yield (0, updateGroupProfile_1.updateGroupProfile)(updateGroupProfileOptions);
            }),
            add: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { role, accounts } = options;
                const validRoles = ['ADMIN', 'MEMBER'];
                if (!validRoles.includes(role)) {
                    throw new Error('Invalid role provided.');
                }
                if (!accounts || accounts.length === 0) {
                    throw new Error('accounts array cannot be empty!');
                }
                accounts.forEach((account) => {
                    if (!(0, helpers_2.isValidETHAddress)(account)) {
                        throw new Error(`Invalid account address: ${account}`);
                    }
                });
                if (role === 'ADMIN') {
                    return yield PUSH_CHAT.addAdmins({
                        chatId: chatId,
                        admins: accounts,
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
                else {
                    return yield PUSH_CHAT.addMembers({
                        chatId: chatId,
                        members: accounts,
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
            }),
            remove: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { role, accounts } = options;
                const validRoles = ['ADMIN', 'MEMBER'];
                if (!validRoles.includes(role)) {
                    throw new Error('Invalid role provided.');
                }
                if (!accounts || accounts.length === 0) {
                    throw new Error('accounts array cannot be empty!');
                }
                accounts.forEach((account) => {
                    if (!(0, helpers_2.isValidETHAddress)(account)) {
                        throw new Error(`Invalid account address: ${account}`);
                    }
                });
                if (role === 'ADMIN') {
                    return yield PUSH_CHAT.removeAdmins({
                        chatId: chatId,
                        admins: accounts,
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
                else {
                    return yield PUSH_CHAT.removeMembers({
                        chatId: chatId,
                        members: accounts,
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
            }),
            join: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const status = yield PUSH_CHAT.getGroupMemberStatus({
                    chatId: target,
                    did: this.account,
                    env: this.env,
                });
                if (status.isPending) {
                    yield PUSH_CHAT.approve({
                        senderAddress: target,
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
                else if (!status.isMember) {
                    return yield PUSH_CHAT.addMembers({
                        chatId: target,
                        members: [this.account],
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
                return yield PUSH_CHAT.getGroup({
                    chatId: target,
                    env: this.env,
                });
            }),
            leave: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const status = yield PUSH_CHAT.getGroupMemberStatus({
                    chatId: target,
                    did: this.account,
                    env: this.env,
                });
                if (status.isAdmin) {
                    return yield PUSH_CHAT.removeAdmins({
                        chatId: target,
                        admins: [this.account],
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
                else {
                    return yield PUSH_CHAT.removeMembers({
                        chatId: target,
                        members: [this.account],
                        env: this.env,
                        account: this.account,
                        signer: this.signer,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                    });
                }
            }),
            reject: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield PUSH_CHAT.reject({
                    senderAddress: target,
                    env: this.env,
                    account: this.account,
                    signer: this.signer,
                    pgpPrivateKey: this.decryptedPgpPvtKey,
                });
            }),
        };
        this.userInstance = new user_1.User(this.account, this.env);
    }
    list(type, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const listParams = {
                account: this.account,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                page: options === null || options === void 0 ? void 0 : options.page,
                limit: options === null || options === void 0 ? void 0 : options.limit,
                env: this.env,
                toDecrypt: true,
            };
            switch (type) {
                case pushAPITypes_1.ChatListType.CHATS:
                    return yield PUSH_CHAT.chats(listParams);
                case pushAPITypes_1.ChatListType.REQUESTS:
                    return yield PUSH_CHAT.requests(listParams);
                default:
                    throw new Error('Invalid Chat List Type');
            }
        });
    }
    latest(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { threadHash } = yield PUSH_CHAT.conversationHash({
                conversationId: target,
                account: this.account,
                env: this.env,
            });
            if (!threadHash)
                return {};
            return yield PUSH_CHAT.latest({
                threadhash: threadHash,
                toDecrypt: true,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                account: this.account,
                env: this.env,
            });
        });
    }
    history(target, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let reference;
            if (!(options === null || options === void 0 ? void 0 : options.reference)) {
                const { threadHash } = yield PUSH_CHAT.conversationHash({
                    conversationId: target,
                    account: this.account,
                    env: this.env,
                });
                reference = threadHash;
            }
            else {
                reference = options.reference;
            }
            if (!reference)
                return [];
            return yield PUSH_CHAT.history({
                account: this.account,
                env: this.env,
                threadhash: reference,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                toDecrypt: true,
                limit: options === null || options === void 0 ? void 0 : options.limit,
            });
        });
    }
    send(recipient, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.type) {
                options.type = constants_1.MessageType.TEXT;
            }
            const sendParams = {
                message: options,
                to: recipient,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                env: this.env,
            };
            return yield PUSH_CHAT.send(sendParams);
        });
    }
    decrypt(messagePayloads) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield PUSH_CHAT.decryptConversation({
                pgpPrivateKey: this.decryptedPgpPvtKey,
                env: this.env,
                messages: messagePayloads,
                connectedUser: yield this.userInstance.info(),
            });
        });
    }
    accept(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield PUSH_CHAT.approve({
                senderAddress: target,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
            });
        });
    }
    reject(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield PUSH_CHAT.reject({
                senderAddress: target,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
            });
        });
    }
    block(users) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const user = yield PUSH_USER.get({
                account: this.account,
                env: this.env,
            });
            for (const element of users) {
                if (!(0, helpers_2.isValidETHAddress)(element)) {
                    throw new Error('Invalid address in the users: ' + element);
                }
            }
            if (!user.profile.blockedUsersList) {
                user.profile.blockedUsersList = [];
            }
            user.profile.blockedUsersList = [
                ...new Set([...user.profile.blockedUsersList, ...users]),
            ];
            return yield PUSH_USER.profile.update({
                pgpPrivateKey: this.decryptedPgpPvtKey,
                account: this.account,
                profile: {
                    name: user.profile.name,
                    desc: user.profile.desc,
                    picture: user.profile.picture,
                    blockedUsersList: user.profile.blockedUsersList,
                },
                env: this.env,
                progressHook: this.progressHook,
            });
        });
    }
    unblock(users) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const user = yield PUSH_USER.get({
                account: this.account,
                env: this.env,
            });
            for (const element of users) {
                if (!(0, helpers_2.isValidETHAddress)(element)) {
                    throw new Error('Invalid address in the users: ' + element);
                }
            }
            if (!user.profile.blockedUsersList) {
                return user;
            }
            const userDIDsPromises = users.map((user) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (yield (0, helpers_1.getUserDID)(user, this.env)).toLowerCase();
            }));
            const userDIDs = yield Promise.all(userDIDsPromises);
            user.profile.blockedUsersList = user.profile.blockedUsersList.filter((blockedUser) => {
                !userDIDs.includes(blockedUser.toLowerCase());
            });
            return yield PUSH_USER.profile.update({
                pgpPrivateKey: this.decryptedPgpPvtKey,
                account: this.account,
                profile: {
                    name: user.profile.name,
                    desc: user.profile.desc,
                    picture: user.profile.picture,
                    blockedUsersList: user.profile.blockedUsersList,
                },
                env: this.env,
                progressHook: this.progressHook,
            });
        });
    }
}
exports.Chat = Chat;
//# sourceMappingURL=chat.js.map