"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushAPI = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../constants");
const PUSH_USER = require("../user");
const PUSH_CHAT = require("../chat");
const helpers_1 = require("../chat/helpers");
const chat_1 = require("./chat");
const profile_1 = require("./profile");
const encryption_1 = require("./encryption");
const user_1 = require("./user");
const PushStream_1 = require("../pushstream/PushStream");
const channel_1 = require("../pushNotification/channel");
const notification_1 = require("../pushNotification/notification");
class PushAPI {
    constructor(signer, env, account, decryptedPgpPvtKey, pgpPublicKey, progressHook) {
        this.signer = signer;
        this.env = env;
        this.account = account;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.pgpPublicKey = pgpPublicKey;
        this.progressHook = progressHook;
        // Instantiate the notification classes
        this.channel = new channel_1.Channel(this.signer, this.env, this.account);
        this.notification = new notification_1.Notification(this.signer, this.env, this.account);
        // Initialize the instances of the four classes
        this.chat = new chat_1.Chat(this.account, this.decryptedPgpPvtKey, this.env, this.signer, this.progressHook);
        this.profile = new profile_1.Profile(this.account, this.decryptedPgpPvtKey, this.env, this.progressHook);
        this.encryption = new encryption_1.Encryption(this.account, this.decryptedPgpPvtKey, this.pgpPublicKey, this.env, this.signer, this.progressHook);
        this.user = new user_1.User(this.account, this.env);
    }
    static initialize(signer, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // Default options
                const defaultOptions = {
                    env: constants_1.ENV.STAGING,
                    version: constants_1.default.ENC_TYPE_V3,
                    autoUpgrade: true,
                    account: null,
                };
                // Settings object
                // Default options are overwritten by the options passed in the initialize method
                const settings = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), { version: (options === null || options === void 0 ? void 0 : options.version) || defaultOptions.version, versionMeta: (options === null || options === void 0 ? void 0 : options.versionMeta) || defaultOptions.versionMeta, autoUpgrade: (options === null || options === void 0 ? void 0 : options.autoUpgrade) !== undefined
                        ? options === null || options === void 0 ? void 0 : options.autoUpgrade
                        : defaultOptions.autoUpgrade });
                // Get account
                // Derives account from signer if not provided
                const derivedAccount = yield (0, helpers_1.getAccountAddress)((0, helpers_1.getWallet)({
                    account: settings.account,
                    signer: signer,
                }));
                let decryptedPGPPrivateKey;
                let pgpPublicKey;
                /**
                 * Decrypt PGP private key
                 * If user exists, decrypts the PGP private key
                 * If user does not exist, creates a new user and returns the decrypted PGP private key
                 */
                const user = yield PUSH_USER.get({
                    account: derivedAccount,
                    env: settings.env,
                });
                if (user && user.encryptedPrivateKey) {
                    decryptedPGPPrivateKey = yield PUSH_CHAT.decryptPGPKey({
                        encryptedPGPPrivateKey: user.encryptedPrivateKey,
                        signer: signer,
                        toUpgrade: settings.autoUpgrade,
                        additionalMeta: settings.versionMeta,
                        progressHook: settings.progressHook,
                        env: settings.env,
                    });
                    pgpPublicKey = user.publicKey;
                }
                else {
                    const newUser = yield PUSH_USER.create({
                        env: settings.env,
                        account: derivedAccount,
                        signer,
                        version: settings.version,
                        additionalMeta: settings.versionMeta,
                        origin: settings.origin,
                        progressHook: settings.progressHook,
                    });
                    decryptedPGPPrivateKey = newUser.decryptedPrivateKey;
                    pgpPublicKey = newUser.publicKey;
                }
                // Initialize PushAPI instance
                const api = new PushAPI(signer, settings.env, derivedAccount, decryptedPGPPrivateKey, pgpPublicKey, settings.progressHook);
                return api;
            }
            catch (error) {
                console.error('Error initializing PushAPI:', error);
                throw error; // or handle it more gracefully if desired
            }
        });
    }
    initStream(listen, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.stream) {
                throw new Error('Stream is already initialized.');
            }
            this.stream = yield PushStream_1.PushStream.initialize(this.account, this.decryptedPgpPvtKey, this.signer, listen, this.env, this.progressHook, options);
            return this.stream;
        });
    }
    info() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield PUSH_USER.get({
                account: this.account,
                env: this.env,
            });
        });
    }
}
exports.PushAPI = PushAPI;
//# sourceMappingURL=PushAPI.js.map